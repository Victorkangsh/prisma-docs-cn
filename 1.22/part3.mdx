import Code from '../home/demos/code'
import {InternalLink} from './text/link';

##  Prisma client

Prisma client是一个自动生成的库，可连接到你的Prisma service。在[this](https://www.prisma.io/blog/prisma-client-beta-ahph4o1umail/)文章中了解更多信息。

### 设置

使用[Prisma CLI]的`prisma generate`命令自动生成Prisma client。 一个Prisma client连接到一个Prisma service。

`prisma generate`读取prisma.yml中`generate`属性下指定的信息。

#### 在prisma.yml中配置`generate`

`generate`根属性接受一个对象列表。 每个对象都有两个字段:

- `generator`: #生成Prisma client的编程语言。
   - 可选的值:`typescript-client`, `javascript-client`, `flow-client`, `go-client`.
   - 即将推出:`reason`
- `output`:应存储Prisma client的文件的路径和名称。

例如，我们看下面的prisma.yml:

<Code lang="yaml">{`
datamodel: datamodel.prisma
endpoint: http://localhost:4000
generate:
  - generator: typescript-client
    output: ./prisma-client/
`}</Code>

在prisma.yml所在的目录中运行`prisma generate`会在TypeScript中生成一个Prisma client，并将其存储在名为`prisma.ts`的文件中。

> `generator`也接受`graphql-schema`作为值。 这将通过[introspection](https://graphql.org/learn/introspection/)查询下载Prisma API的GraphQL schema。

##### 更多例子

当`generate`接受一个对象列表时，你也可以同时生成多个文件:

<Code lang="yaml">{`
datamodel: datamodel.prisma
endpoint: http://localhost:4466
secret: mysecret42
generate:
  - generator: typescript-client
    output: ./prisma-client-ts/
  - generator: javascript-client
    output: ./prisma-client-js/
  - generator: go-client
    output: ./prisma-client-go/
  - generator: flow-client
    output: ./prisma-client-flow/
  - generator: graphql-schema
    output: ./graphql-schema/
`}</Code>

#### 生成的代码
假设Prisma service的数据模型定义如下:

<Code lang="graphql">{`
type Link {
  id: ID! @unique
  createdAt: DateTime!
  description: String!
  url: String!
  postedBy: User
  votes: [Vote!]!
}
type User {
  id: ID! @unique
  name: String!
  email: String! @unique
  password: String!
  links: [Link!]!
  votes: [Vote!]!
}
type Vote {
  id: ID! @unique
  link: Link!
  user: User!
}
`}</Code>

你可以在你电脑本地或者此处查看生成的文件的代码:

- [适用于JavaScript的Prisma client](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.js)
- [TypeScript的Prisma client](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts)
- [Prisma API的GraphQL schema](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.graphql)

生成的Prisma client已经知道在生成时prisma.yml中指定的`endpoint`和`secret`。


#### 构造函数-JavaScript

`Prisma`构造函数用于创建Prisma client的新实例。

<Code lang="javascript">{`
constructor(options: BasePrismaOptions)
`}</Code>

`BasePrismaOptions`具有以下属性(都是可选的):

- `endpoint: string`:Prisma service的端点。 如果未提供，则client将默认使用在生成client时在prisma.yml中指定的"端点"。
- `secret: string`:保护Prisma serviceAPI的密码。 如果未提供，client将默认使用在生成client时在prisma.yml中指定的`secret`。
- `debug: boolean`:如果设置为`true`，Prisma client上每个方法的调用都会打印发送到Prisma API的GraphQL查询到控制台。 **默认值:`false`**。
- `fragmentReplacements: FragmentReplacement []`:将应用于发送到Prisma API的每个Query/Mutation/Subscriptions的GraphQL片段列表。

##### 例子

_使用client generate时在prisma.yml中指定的`endpoint`和`secret`的默认值:_

<Code lang="javascript">{`
const prisma = new Prisma({})
`}</Code>

_覆盖默认值:_
<Code lang="javascript">{`
const prisma = new Prisma({ 
  endpoint: "http://localhost:4466/hello-world/dev",
  secret: "mysecret42",
})
`}</Code>

#### 构造函数-TypeScript

`Prisma`构造函数用于创建Prisma client的新实例。

<Code lang="javascript">{`
constructor(options: BasePrismaOptions)
`}</Code>

`BasePrismaOptions`具有以下属性(都是可选的):

- `endpoint:string`:Prisma service的端点。 如果未提供，则client将默认使用在生成client时在prisma.yml中指定的"端点"。
- `secret:string`:保护Prisma serviceAPI的密码。 如果未提供，client将默认使用在生成client时在prisma.yml中指定的`secret`。
- `debug:boolean`:如果设置为`true`，Prisma client上每个方法的调用都会打印发送到Prisma API的GraphQL查询到控制台。 **默认值:`false`**。
- `fragmentReplacements:FragmentReplacement []`:将应用于发送到Prisma API的每个Query/Mutation/Subscriptions的GraphQL片段列表。

##### 例子

_使用client生成时在prisma.yml中指定的`endpoint`和`secret`的默认值:_


<Code lang="javascript">{`
const prisma = new Prisma({})
`}</Code>

_覆盖默认值:_

<Code lang="javascript">{`
const prisma = new Prisma({ 
  endpoint: "http://localhost:4466/hello-world/dev",
  secret: "mysecret42",
})
`}</Code>

#### 构造函数-Go

`Prisma`构造函数用于创建Prisma client的新实例。

<Code lang="go">{`
New(options PrismaOptions) Client
`}</Code>

`PrismaOptions`具有以下属性(都是可选的):

- `endpoint:string`:Prisma service的端点。 如果未提供，则client将默认使用在生成client时在prisma.yml中指定的"端点"。
- `debug:boolean`:如果设置为`true`，Prisma client上每个方法的调用都会打印发送到Prisma API的GraphQL查询到控制台。 **默认值:`false`**。

##### 例子

_使用client生成时在prisma.yml中指定的`endpoint`和`secret`的默认值:_

<Code lang="go">{`
db := prisma.New(nil)
`}</Code>

_覆盖默认值:_

<Code lang="go">{`
client := prisma.New(&prisma.PrismaOptions{
  Endpoint: "http://localhost:4466/hello-world/dev",
  Debug: true,
})
`}</Code>



### 读取数据-JavaScript

Prisma client基于Prisma API的GraphQL schema定义生成操作。对于_reading_数据，它基本上_复制_你Prisma service中的`GraphQL Query`。

对于此页面，我们假设你的Prisma API基于以下`datamodel`:

<Code lang="graphql">{`
type Link {
  id: ID! @unique
  createdAt: DateTime!
  description: String!
  url: String!
  postedBy: User
  votes: [Vote!]!
}
type User {
  id: ID! @unique
  name: String!
  email: String! @unique
  password: String!
  links: [Link!]!
  votes: [Vote!]!
}
type Vote {
  id: ID! @unique
  link: Link!
  user: User!
}
`}</Code>

- 你可以查看API生成的GraphQL schema[这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.graphql)
- 你可以查看生成的JavaScript client[此处](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.js)。

每当使用Prisma client查询模型时，都会获取该模型的_所有字段_。无论是查询单个对象还是对象列表，都是如此。

例如，以下查询返回单个"User"的所有标量字段:

<Code lang="javascript">{`
const user = await prisma.user({ email: "bob@prisma.io" })
`}</Code>

在这种情况下，返回的`user`对象将具有四个属性(对应于`User`模型的标量字段):`id`，`name`，`email`和`password`。

`links`和`votes`字段都是_relation fields_，因此不包含在查询中。

以下是获取所有`User`对象_列表_的示例:

<Code lang="javascript">{`
const users = await prisma.users()
`}</Code>

与前面的查询类似，`users`数组中的每个对象只有标量和无关系字段。

#### 获取单个对象

对于datamodel中的每个模型类型，在Prisma clientAPI中生成一种方法，允许获取该模型的单个对象。 该方法以类型命名，但以_小写_字符开头。 对于上面的示例数据模型，获取单个"User"，"Link"和"Vote"对象的三种方法称为"user"，"link"和"vote"。

这些函数的输入是一个对象，它具有模型的任何 **唯一字段**作为属性。 这意味着，对于所有三种方法，都接受`id`字段(因为相应的模型每个都有一个注释为`@unique`的`id`字段)。 `user`方法的输入对象另外有一个`email`字段可以来查询。

- 查看`Link`的"where"类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L455)
- 查看`User`的"where"类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L357)
- 查看`Vote`的"where"类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L522)

##### 例子

**以下所有例子中，第一段代码为resolvers中的代码，第二段是playground中的操作**

_通过其id_获取单个投票:

<Code lang="javascript">{`
const vote = await prisma.vote({ id: "cjlgpyueg001o0a239d3i07ao" })
`}</Code>

<Code lang="graphql">{`
# generated query
query {
  vote(where: {
    id: "cjlgpyueg001o0a239d3i07ao"
  }) {
    id
  }
}
`}</Code>


_通过email_获取单个用户:

<Code lang="javascript">{`
const user = await prisma.user({ email: "alice@prisma.io" })
`}</Code>

<Code lang="graphql">{`
# generated query
query {
  user(where: {
    email: "alice@prisma.io"
  }) {
    id
  }
}
`}</Code>


#### 获取列表

对于datamodel中的每个模型类型，在Prisma clientAPI中生成一个方法，允许获取这些模型对象的列表。 该方法以模型命名，但以_小写_字符开头并使用_复数_形式。 对于上面的示例数据模型，获取"User"，"Link"和"Vote"模型列表的三种方法称为"users"，"links"和"votes"。

这些函数的输入参数是一个具有以下属性的对象:

- [过滤](#列表基础过滤):`where`
- [排序](#排序):`orderBy`
- [分页](#分页):`before`，`after`，`first`，`last`，`skip`

##### 例子

_获取所有links_:

<Code lang="javascript">{`
const links = await prisma.links()
`}</Code>

<Code lang="graphql">{`
# generated query
query {
  links {
    id
    createdAt
    url
    description
  }
}
`}</Code>

_获取users_列表:

<Code lang="javascript">{`
const users = await prisma.users()
`}</Code>

<Code lang="graphql">{`
query {
  links {
    id
    createdAt
    url
    description
  }
}
`}</Code>

#### 关系

Prisma client基于[fluent API](https://www.sitepoint.com/javascript-like-boss-understanding-fluent-apis/)来查询数据图中的关系。这意味着你可以简单地_链式调用_你的方法来返回模型的关系属性。

**注意**

这仅在检索_单个_对象时才有可能，而不是用于列表。这意味着你无法查询列表中返回的对象的关系字段，例如:

<Code lang="javascript">{`
//不可能
const result = await prisma
  .users()
  .links()
`}</Code>

在这个例子中，`users()`已经返回一个列表，因此不可能查询列表中每个用户对象的`links`关系。



##### 例子

_Query查询单个user_的所有链接:

<Code lang="javascript">{`
const linksByUser = await prisma
  .user({ email: "alice@prisma.io" })
  .links()
`}</Code>

<Code lang="graphql">{`
query {
  user(where: {
    email: "alice@prisma.io"
  }) {
    links {
      id
      createdAt
      description
      url
    }
  }
}
`}</Code>

 _查询某个user_所做的所有投票:

<Code lang="javascript">{`
const votesByUser = await prisma
  .user({ email: "alice@prisma.io" })
  .votes()
`}</Code>

<Code lang="graphql">{`
query {
  user(where: {
    email: "alice@prisma.io"
  }) {
    votes {
      id
    }
  }
}
`}</Code>



#### 使用片段fragment进行细粒度数据访问

你可以使用`$fragment` API功能(基于GraphQL)指定要检索的字段，而不是查询模型的所有标量字段(这是默认行为)。这对于排除大量不需要的字段(如BLOB值或大字符串)或检索关系很有用。

##### 例子

_获取用户的`name`和`email`以及相关links_的`description`和`url`:

<Code lang="javascript">{`
const fragment = \`
fragment UserWithLinks on User {
  name
  email
  links {
    description
    url
  }
}
\`
const userWithPosts = await prisma.users().\$fragment(fragment)
`}</Code>

<Code lang="graphql">{`
query {
  users {
    ...UserWithLinks
  }
}
fragment UserWithLinks on User {
  name
  email
  links {
    description
    url
  }
}
`}</Code>



#### 列表的基本过滤器

_Basic_过滤器允许你指定某些条件来约束应在列表中返回哪些对象。过滤器在输入参数的`where`对象中指定，任何列表查询都接受该对象。

`where`对象的类型取决于生成它的模型。

查看`Link`，`User`和`Vote` 的`where`类型

- 查看`Link`的"where"类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L154)
- 查看`User`的"where"类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L267)
- 查看`Vote`的"where"类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L219)

也可以使用`AND`和`OR`字段_组合_多个过滤器。

##### 例子

找到名称中包含"A"的用户:

<Code lang="javascript">{`
const usersWithAInName = await prisma
  .users({
    where: {
      name_contains: "A"
    }
  })
`}</Code>

<Code lang="graphql">{`
query {
  users(where: {
      name_contains: "A"
  }) {
    id
    name
    email
    password
  }
}
`}</Code>

使用自动完成功能来探索过滤系统

![](https://imgur.com/XwE5z9o.png)

_查询称为"Alice"或"Bob`的用户_:

<Code lang="javascript">{`
const usersCalledAliceOrBob = await prisma
  .users({
    where: {
      name_in: ["Alice", "Bob"]
    }
  })
`}</Code>

<Code lang="graphql">{`
query {
  users(where: {
    name_in: ["Alice", "Bob"]
  }) {
    id
    name
    email
    password
  }
}
`}</Code>

_获取2018年12月24日之前创建的链接_:

<Code lang="javascript">{`
const linksBeforeChristmas = await prisma
  .links({
    where: {
      createdAt_lt: "2018-12-24" 
    }
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(where: {
    createdAt_lt: "2018-12-24" 
  }) {
    id
    createdAt
    description
    url
  }
}
`}</Code>

> Prisma client API中的日期和时间遵循[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)标准，该标准通常具有以下形式:`YYYY-MM-DDThh:mm:ss`。

_查询在description中有`prisma` **或**`graphql`的链接**并且是**在2018年创建的_:

<Code lang="javascript">{`
const filteredLinks = await prisma
  .links({
    where: {
      AND: [
        {
          OR: [{
            description_contains: "graphql",
          }, {
            description_contains: "prisma",
          }]
        }, 
        {
          AND: [{
            createdAt_gt: "2017"
          }, {
            createdAt_lt: "2019"
          }]
        }
      ],
    }
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(where: {
    OR: [{
      description_contains: "graphql",
    }, {
      description_contains: "prisma",
    }]
    AND: [{ 
      createdAt_lt: "2019"
    }, { 
      createdAt_gt: "2017" 
    }]
  }) {
    id
    description
  }
}
`}</Code>

实际上可以省略`AND`过滤器，因为默认情况下使用_logical and_组合了多个过滤条件。这意味着上面的过滤器也可以表示如下:

<Code lang="javascript">{`
const filteredLinks = await prisma
  .links({
    where: {
      OR: [{
        description_contains: "graphql"
      }, {
        description_contains: "prisma"
      }],
      createdAt_gt: "2017",
      createdAt_lt: "2019"
    }
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(where: {
    OR: [{
      description_contains: "graphql",
    }, {
      description_contains: "prisma",
    }],
    createdAt_lt: "2019",
    createdAt_gt: "2017" 
  }) {
    id
    createdAt
    description
    url
  }
}
`}</Code>

#### 列表的关系过滤器

关系过滤器可用于约束关系列表字段上的返回对象。用于过滤的类型与基本过滤器相同，唯一的区别是过滤器不应用于方法调用的第一级，而是在第二级查询关系时。

##### 例子

<Code lang="javascript">{`
const linksByUserBeforeChristmas = await prisma
  .user({ email: "alice@prisma.io" })
  .links({
    where: {
      createdAt_lt: "2017-12-24" 
    }
  })
`}</Code>

<Code lang="graphql">{`
query {
 user(where: {
  email: "alice@prisma.io"
 }) {
    links(where: {
      createdAt_lt: "2017-12-24" 
    }) {
      id
      createdAt
      description
      url
  }
 }
}
`}</Code>



#### 排序

查询模型对象列表时，可以按该模型类型的任何标量字段对列表进行排序。因此，每个生成的查询模型列表的方法都接受其输入对象上的`orderBy`字段。

`orderBy`字段的类型取决于生成它的模型的标量字段。

查看`link`，`user`和`Vote`的`orderBy`类型

- 查看`link` 的`orderBy`类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L114)
- 查看`user` 的`orderBy`类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L132)
- 查看`Vote` 的`orderBy`类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L125)



##### 例子

_按创建日期(升序)_links:

<Code lang="javascript">{`
const sortedLinks = prisma
  .links({
    orderBy: "createdAt_ASC"
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(orderBy: createdAt_ASC) {
    id
    createdAt
    description
    url
  }
}
`}</Code>



_按字母顺序排序用户名(降序)_:

<Code lang="javascript">{`
const sortedUsers = prisma
  .users({
    orderBy: "name_DESC"
  })
`}</Code>

<Code lang="graphql">{`
query {
  users(orderBy: name_DESC) {
    id
    name
    email
    password
  }
}
`}</Code>




#### 分页

查询模型对象列表时，可以通过提供分页参数来获取该列表的_部分信息_。常在feed流中使用。

##### 用'first`和`last`向前和从后往前

你可以在对象中向前或从后往前并提供可选的起始对象:

- 要 **从前往后**，使用`first`;用`after`指定一个起始对象。
- 要 **从后往前**，请使用`last`;用`before`指定一个起始对象。

你 **不能**将`first`与`before`或`last`与`after`结合起来。如果你在查询中这样做，`before`/`after`将被忽略，实际上只应用`first`或`last`(在列表的开头或结尾，取决于你使用的是哪个) 。

请注意，你可以在没有错误消息的情况下查询比实际存在的对象更多的对象。

##### 使用`skip`跳过元素

你还可以通过提供`skip`参数跳过任意方向的任意数量的对象:

- 当使用`first`时，`skip`会跳过列表开头的对象。
- 当使用`last`时，`skip`跳过列表末尾的对象。

##### 例子

对于以下示例，我们假设一个正好包含30个对象的列表:

![](https://i.imgur.com/Xh6Qjts.png)

_查询前3个链接(从前往后)_:

![](https://i.imgur.com/O1Jj3Z2.png)

<Code lang="javascript">{`
const links = await prisma
  .links({
    first: 3
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(first: 3) {
    id
    createdAt
    description
    url
  }
}
`}</Code>



_查询从位置6到位置10的对象(从前往后)_:

![](https://i.imgur.com/PpI5X0X.png)

<Code lang="javascript">{`
const links = await prisma
  .links({
    first: 5, 
    skip: 5
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(
    first: 5 
    skip: 5
  ) {
    id
    createdAt
    description
    url
  }
}
`}</Code>



_查询最后3个对象(从后往前)_:

![](https://i.imgur.com/pkuYCrV.png)

<Code lang="javascript">{`
const links = await prisma
  .links({
    last: 3
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(last: 3) {
    id
    createdAt
    description
    url
  }
}
`}</Code>



_查询从第21位到第27位的对象(从后往前)_:

![](https://i.imgur.com/iSl9Y07.png)

<Code lang="javascript">{`
const links = await prisma
  .links({
    last: 7,
    skip: 3
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(
    last: 7
    skip: 3
  ) {
    id
    createdAt
    description
    url
  }
}
`}</Code>



使用`cixnen24p33lo0143bexvr52n`作为`id`_查询对象之后的前3个对象_:

![](https://i.imgur.com/InYSSkQ.png)

<Code lang="javascript">{`
const links = await prisma
  .links({
    first: 3,
    after: "cixnen24p33lo0143bexvr52n"
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(
    first: 3
    after: "cixnen24p33lo0143bexvr52n"
  ) {
    id
    createdAt
    description
    url
  }
}
`}</Code>



使用`cixnen24p33lo0143bexvr52n`作为`id`跳过3条数据查询后面的5个对象:

![](https://i.imgur.com/u4WEAJv.png)

<Code lang="javascript">{`
const links = await prisma
  .links({
    first: 5,
    after: "cixnen24p33lo0143bexvr52n",
    skip: 3
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(
    first: 5
    after: "cixnen24p33lo0143bexvr52n"
    skip: 3
  ) {
    id
    createdAt
    description
    url
  }
}
`}</Code>



使用`cixnen24p33lo0143bexvr52n`作为`id`_查询对象之前的最后5个对象_:

![](https://i.imgur.com/306eghw.png)

<Code lang="javascript">{`
const links = await prisma
  .links({
    last: 5,
    before: "cixnen24p33lo0143bexvr52n"
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(
    last: 5
    before: "cixnen24p33lo0143bexvr52n"
  ) {
    id
    createdAt
    description
    url
  }
}
`}</Code>



_查询节点之前的最后3个节点，其中cixnen24p33lo0143bexvr52n为id并跳过5个_:

![](https://i.imgur.com/iZGUiHJ.png)

<Code lang="javascript">{`
const links = await prisma
  .links({
    last: 3,
    before: "cixnen24p33lo0143bexvr52n",
    skip: 5
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(
    last: 3 
    before: "cixnen24p33lo0143bexvr52n"
    skip: 5
  ) {
    id
    createdAt
    description
    url
  }
}
`}</Code>



#### 聚合

你可以通过[Connection查询]提交聚合查询。支持以下聚合功能:

- `count`:计算列表中的对象数
- `avg`(_即将推出_):计算数字列表的平均值。
- `median`(_即将推出_):计算数字列表的中位数。
- `max`(_即将推出_):返回数字列表中最大的元素。
- `min`(_即将推出_):返回数字列表中的最小元素。
- `sum`(_即将推出_):计算数字列表的总和。

> 请参阅[this](https://github.com/prisma/prisma/issues/1312)GitHub问题以了解有关即将推出的聚合功能的更多信息。

##### 例子

_Count链接对象的数量_:

<Code lang="javascript">{`
const linkCount = await prisma
  .linksConnection()
  .aggregate()
  .count()
`}</Code>

<Code lang="graphql">{`
query {
  linksConnection {
    aggregate {
      count
    }
  }
}
`}</Code>

### 写入数据-JavaScript


对于前面创建的的数据模型，每个模型类型生成了写入数据六种方法。这些在GraphQL schema，例如用于`User`模型中的Mutation而得到:

- `createUser`:创建一个新的`User`记录在数据库中 
- `updateUser`:更新现有`User`记录在数据库中
- `deleteUser`:从数据库中删除现有的`User`记录
- `upsertUser`:更新现有的或在数据库中创建一个新的`User`纪录
- `updateManyUsers`:更新许多现有的`User`数据库中的记录
- `deleteManyUsers`:从数据库中删除现有的许多`User`记录

- 你可以查看一下生成GraphQL schema的API [这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.graphql)
- 你可以查看要生成的JavaScript client[这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.js)。



这些方法中的一个的每个调用被作为[事务]执行，这意味着它要么保证完全成功，或者如果它只是部分地失败但要被全部取消而回到原先状态，所以不必担心数据一致性。

#### 创建对象

当在数据库中创建新的记录，`create`方法需要用一个输入对象包裹起来所有数据。它还提供了一种用于模型创建关系数据，这可以通过使用[嵌套对象写入](#嵌套对象写入)来提供。

每个方法调用的返回包含刚刚创建的模型的所有字段。

- 查看createLink`的`的输入对象的类型(这里)(https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L567)
- 查看createUser`的`的输入对象的类型(这里)(https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L418)
- 查看createVote`的`的输入对象的类型(这里)(https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L214)

##### 例子

_create新用户_:

<Code lang="javascript">{`
const newUser = await prisma
  .createUser({
    name: "Alice",
    email: "alice@prisma.io",
    password: "IlikeTurtles"
  })
`}</Code>

<Code lang="graphql">{`
# generated mutation
mutation {
  createUser(data: {
    name: "Alice"
    email: "alice@prisma.io"
    password: "IlikeTurtles"
  }) {
    id
    name
    email
    password
  }
}
`}</Code>



_create新vote_:

<Code lang="javascript">{`
const newVote = await prisma
  .createVote({
    user: {
      connect: {
        email: "alice@prisma.io"
      }
    },
    link: {
      connect: {
        id: "cjli47wr3005b0a23m9crhh0e"
      }
    }
  })
`}</Code>

<Code lang="graphql">{`
# generated mutation
mutation {
  createVote(data: {
    user: {
      connect: {
        email: "alice@prisma.io"
      }
    }
    link: {
      connect: {
        id: "cjli47wr3005b0a23m9crhh0e"
      }
    }
  }) {
    id
  }
}
`}</Code>



_create新用户并加两个新links_:

<Code lang="javascript">{`
const newUserWithLinks = await prisma
  .createUser({
    name: "Alice",
    email: "alice@prisma.io",
    password: "IlikeTurtles",
    links: {
      create: [{
        description: "My first link",
        url: "https://www.prisma.io"
      }, {
        description: "My second link",
        url: "https://www.howtographql.com"
      }]
    }, 
  })
`}</Code>

<Code lang="graphql">{`
# generated mutation
mutation {
  createUser(data: {
    name: "Alice"
    email: "alice@prisma.io"
    password: "IlikeTurtles"
    links: {
      create: [{
        description: "My first link",
        url: "https://www.prisma.io"
      }, {
        description: "My second link",
        url: "https://www.howtographql.com"
      }]
    }
  }) {
    id
    name
    email
    password
  }
}
`}</Code>

#### 更新对象

当在数据库中更新现有记录中，`update`-方法接收具有两个字段的一个输入对象:

 - `data`:这类似于你提供给一个`create`-方法输入对象。它包含模型更新的字段，让你提供的关系数据通过[嵌套对象写入](#嵌套对象写入)。
 - `where`:这是用来选择要更新的记录。你可以使用任何[唯一]字段来标识记录。

查看`data`的类型和`where`用于`Link`，`User`和`Vote`

- `data`
  - 查看`updateLink`的`data`字段的类型[这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L255)
  - 查看`updateUser`的`data`字段的类型[这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L468)
  - 查看`updateVote`的`data`字段的类型[这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L366)
- `where`
  - 查看`updateLink`的`where`字段的类型[这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L455)
  - 查看`updateUser`的`where`字段的类型[这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L357)
  - 查看`updateVote`的`where`字段的类型[这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L522)

每个方法调用返回一个包含刚更新了模型的所有字段的对象。

##### 例子

_设置现有用户_一个新的名字:

<Code lang="javascript">{`
const updatedUser = await prisma
  .updateUser({
    data: {
      name: "Alice"
    },
    where: {
      id: "cjli512bd005g0a233s1ogbgy"
    }
  })
`}</Code>

<Code lang="graphql">{`
# generated mutation
mutation {
  updateUser(
    data: {
      name: "Alice"
    }
    where: {
      id: "cjli512bd005g0a233s1ogbgy"
    }
  ) {
    id
    name
    email
    password
  }
}
`}</Code>

_Update一个链接，改变它的发布者为不同的用户_:

<Code lang="javascript">{`
const updatedLink = await prisma
  .updateLink({
    data: {
      postedBy: {
        connect: {
          id: "cjli512bd005g0a233s1ogbgy"
        }
      },
    },
    where: {
      id: "cjli47wr3005b0a23m9crhh0e"
    }
  })
`}</Code>

<Code lang="graphql">{`
mutation {
  updateLink(
    data: {
      postedBy: {
        connect: {
          id: "cjli512bd005g0a233s1ogbgy"
        }
      }
    }
    where: {
      id: "cjli47wr3005b0a23m9crhh0e"
    }
  ) {
    id
    createdAt
    description
    url
  }
}
`}</Code>



_delete发布vote的用户_:

<Code lang="javascript">{`
const updatedVote = await prisma
  .updateVote({
    data: {
      user: {
        delete: true
      },
    },
    where: {
      id: "cjli5aual005n0a233ekv89o4"
    }
  })
`}</Code>

<Code lang="graphql">{`
mutation {
  updateVote(
    data: {
      user: {
        delete: true
      }
    }
    where: {
      id: "cjli5aual005n0a233ekv89o4"
    }
  ) {
    id
  }
}
`}</Code>

> 为了成功执行此操作，vote的user不能是必填字段。否则，每一个`Vote`需要连接到一个`User`，删除就报错了。  

#### 删除对象

当从数据库中删除记录，该`delete`-方法接收一个输入对象，指定哪个记录是要被删除。类型此输入对象的是相同的`update`-方法`where`对象。

该对象的属性对应于被标记为[唯一](#唯一)的模型的那些字段。对于上面的示例数据模型，这意味着，对于`User`，`Vote`和`Link`它有一个`id`属性。对于`User`它另外接受`email`字段。

查看类型的输入对象的`Link`，`User`和`Vote` 

- 查看deleteLink`的`的输入对象的类型(这里)(https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L455)
- 查看deleteUser`的`的输入对象的类型(这里)(https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L357)
- 查看deleteVote`的`的输入对象的类型(这里)(https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L522)

每个方法调用返回一个包含刚删除的模型的所有字段的对象。

##### 例子

_delete其ID_链接:

<Code lang="javascript">{`
const deletedLink = await prisma
  .deleteLink({
    id: "cjli47wr3005b0a23m9crhh0e"
  })
`}</Code>

<Code lang="graphql">{`
mutation {
  deleteLink(where: {
    id: "cjli47wr3005b0a23m9crhh0e"
  }) {
    id
    createdAt
    description
    url
  }
}
`}</Code>

_通过他们的email来delete_用户:

<Code lang="javascript">{`
const deletedUser = await prisma
  .deleteUser({
    email: "alice@prisma.io"
  })
`}</Code>

<Code lang="graphql">{`
mutation {
  deleteUser(where: {
    email: "alice@prisma.io"
  }) {
    id
    createdAt
    description
    url
  }
}
`}</Code>

#### 创建或更新对象(upserts)

UPSERT操作允许你_尝试_更新现有的记录。如果该记录实际上还不存在，它将被创建。该`upsert`的方法是`create`-和`update`-的搭配方法，这意味着他们收到有三个字段输入参数:

- `where`:相同于在`update`方法中提供的`where`字段
- `update`:相同于在`update`的方法中提供的`data`字段
- `create`:相同于在`create`的方法中提供的输入input

##### 例子

_Update链接的URL。如果该链接不存在，创建一个新的_:

<Code lang="javascript">{`
const updatedOrCreatedLink = await prisma
  .upsertLink({
    where: {
      id: "cjli47wr3005b0a23m9crhh0e"
    },
    update: {
      url: "https://www.howtographql.com"
    },
    create: {
      url: "https://www.howtographql.com",
      description: "Fullstack GraphQL Tutorial"
    }
  })
`}</Code>

<Code lang="graphql">{`
mutation {
  upsertLink(
    where: {
      id: "cjli47wr3005b0a23m9crhh0e"
    }
    update: {
      url: "https://www.howtographql.com"
    }
    create: {
      url: "https://www.howtographql.com"
      description: "Fullstack GraphQL Tutorial"
    }
  ) {
    id
  }
}
`}</Code>




#### 更新和删除多条记录

该Prisma的clientAPI提供了特殊的方法来更新或一次删除多条记录。GraphQL API中的相应的Mutation被称为[批量Mutation(#批量Mutation)。每个`updateMany`-和`deleteMany`-方法返回最终受到影响的操作记录数。

##### 例子

_Update三个links，通过其ID指定，将其网址重置为空string_:

<Code lang="javascript">{`
const updatedLinksCount = await prisma
  .updateManyLinks({
    where: {
      id_in: ["cjli6tknz005s0a23uf0lmlve", "cjli6tnkj005x0a2325ynfpb9", "cjli6tq3200620a23s4lp8npd"]
    },
    data: {
      url: ""
    },
  }).count
`}</Code>

<Code lang="graphql">{`
mutation {
  updateManyLinks({
    where: {
      id_in: ["cjli6tknz005s0a23uf0lmlve", "cjli6tnkj005x0a2325ynfpb9", "cjli6tq3200620a23s4lp8npd"]
    }
    data: {
      url: ""
    }
  }) {
    count
  }
}
`}</Code>



**注意**

如果一个或多个所提供的ID没有在数据库中实际存在，操作将 **不返回**错误。

_Update 所有links的描述中包含字符串'graphql`的数据，其网址重置为空string_:

<Code lang="javascript">{`
const updatedLinksCount = await prisma
  .updateManyLinks({
    where: {
      description_contains: "graphql"
    },
    data: {
      url: ""
    },
  }).count
`}</Code>

<Code lang="graphql">{`
mutation {
  updateManyLinks({
    where: {
      description_contains: "graphql"
    }
    data: {
      url: ""
    }
  }) {
    count
  }
}
`}</Code>



_delete在2018年之前创建的所有链接_:

<Code lang="javascript">{`
const deleteLinksCount = await prisma
  .deleteManyLinks({
    createdAt_lte: "2018"
  }).count
`}</Code>

<Code lang="graphql">{`
mutation {
  deleteManyLinks(where: {
    createdAt_lte: "2018"
  }) {
    count
  }
}
`}</Code>



#### 嵌套对象写入

嵌套的对象写入操作让你在一个单一的Mutation中修改多个模型数据库记录。Prisma的GraphQL API相应的概念被称为[嵌套Mutation](#嵌套的Mutation)。嵌套对象写入可供`create`-和`update`的方法。

如果模型具有相对于不同的schema，对应关系字段被设定为具有以下性质中的一个子集的对象:

- `create`:创建相关模型的新纪录，并通过关系将其连接。
- `update`:更新通过关系已经连接了相关模型的现有记录。
- `upsert`:更新相关模型的现有记录或创建并连接一个新的。 
- `delete`:删除通过关系连接的相关模型的现有记录。
- `connect`:通过连接关系的相关模型的现有记录。
- `disconnect`:删除通过关系连接相关模型的现有记录。

##### 例子

_create新用户和两个新的link，并连接一个现有的link_:

<Code lang="javascript">{`
const newUserWithLinks = await prisma
  .createUser({
    name: "Alice",
    email: "alice@prisma.io",
    password: "IlikeTurtles",
    links: {
      create: [{
        description: "My first link",
        url: "https://www.prisma.io"
      }, {
        description: "My second link",
        url: "https://www.howtographql.com"
      }],
      connect: {
        id: "cjli6tknz005s0a23uf0lmlve"
      }
    }, 
  })
`}</Code>

<Code lang="graphql">{`
# generated mutation
mutation {
  createUser(data: {
    name: "Alice"
    email: "alice@prisma.io"
    password: "IlikeTurtles"
    links: {
      create: [{
        description: "My first link",
        url: "https://www.prisma.io"
      }, {
        description: "My second link",
        url: "https://www.howtographql.com"
      }]
      connect: {
        id: "cjli6tknz005s0a23uf0lmlve"
      }
    }
  }) {
    id
    name
    email
    password
  }
}
`}</Code>



_delete用户的链接_:

<Code lang="javascript">{`
const updatedUser = await prisma
  .updateUser({
    where: {
      id: "cjli8znnd006n0a23ywc6wf8w"
    },
    data: {
      links: {
        delete: {
          id: "cjli6tknz005s0a23uf0lmlve"
        }
      }
    }
  })
`}</Code>

<Code lang="graphql">{`
mutation {
  updateUser(
    where: {
      id: "cjli8znnd006n0a23ywc6wf8w"
    }
    data: {
      links: {
        delete: {
          id: "cjli6tknz005s0a23uf0lmlve"
        }
      }
    }
  ) {
    id
  }
}
`}</Code>


#### 实时数据-JavaScript

该Prisma的client，使用`\$subscribe`属性实时更新和订阅数据库事件和数据。对于你的数据模型中的每个模型类型，Prisma client公开以此属性的模型命名的(小写)一个函数：Subscriptions。使用此函数意味着比对该模型的[写入]事件（即_create_，_update_，_delete_）有实时需求。你可以提供一个过滤器对象，使得可以进一步约束要接收更新的事件类型。该函数返回[async iterator](https://github.com/tc39/proposal-async-iteration)，只要发生指定的数据库事件，就会发出事件通知。

该`\$subscribe` API是基于[WebSockets的(https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)。

##### 例子

_Subscribe"新建"和"更新"`User`_的事件:

<Code lang="javascript">{`
const createdAndUpdatedUserIterator = await prisma.$subscribe.user({
  mutation_in: ['CREATED', 'UPDATED']
}).node()
`}</Code>

 _Subscribe`User`的电子邮件地址有包含字符串'gmail`的更新:

 <Code lang="javascript">{`
const userIterator = await prisma.$subscribe.user({
  email_contains: \`gmail\` 
}).node()
`}</Code>

### 检查是否存在-JavaScript

该Prisma的client，你可以为你在使用`$exists`属性中的数据库中是否存在一定的记录。对于你的[数据模型]每个模型类型，Prisma client公开此属性的模型命名的(小写)一个函数。这些函数的接收过滤对象作为指定该记录的条件，并返回一个布尔值;如果有至少一个数据库记录符合指定过滤，该值是TRUE，否则返回FALSE。

输入对象具有用于[过滤列表]相同的类型。

#### 例子

_检查是否有具有特定ID 存在_的用户:

<Code lang="javascript">{`
const userExists = prisma.$exists.user({
  id: "cjli6tko8005t0a23fid7kke7"
})
`}</Code>

_检查是否有用户名为`Alice`或`Bob` 的user存在_:

<Code lang="javascript">{`
const userExists = prisma.$exists.user({
  name_in: ['Alice', 'Bob']
})
`}</Code>

检查是否有在描述中有`prisma`或`graphql`字段存在的link，并且创建于2018年:

<Code lang="javascript">{`
const linkExists = await prisma.$exists.link({
  AND: [
    {
      OR: [{
        description_contains: "graphql",
      }, {
        description_contains: "prisma",
      }]
    },
    {
      AND: [{
        createdAt_gt: "2017"
      }, {
        createdAt_lt: "2019"
      }]
    }
  ],
})
`}</Code>

### graphql-requests-JavaScript

该Prisma的client，可以直接发送GraphQL Query和Mutation，`$request`方法请求你的Prisma service:

<Code lang="typescript">{`
$request: <T = any>(query: string, variables?: {[key: string]: any}) => Promise<T>;
`}</Code>

#### 例子

_查询单个用户_:

<Code lang="javascript">{`
  query {
    user(id: "cjcdi63j80adw0146z7r59bn5") {
      id
      name
    }
  }
prisma.request(query)
  .then(result => console.log(result))
// 示例result:
// {"data": { "user": { "id": "cjcdi63j80adw0146z7r59bn5", "name": "Sarah" } } }
`}</Code>


_使用variables查询_单个用户:

<Code lang="javascript">{`
  query ($userId: ID!){
    user(id: $userId) {
      id
      name
    }
  }
const variables = { userId: 'cjcdi63j80adw0146z7r59bn5' }
prisma.request(query, variables)
  .then(result => console.log(result))
// 示例result:
// {"data": { "user": { "id": "cjcdi63j80adw0146z7r59bn5", "name": "Sarah" } } }
`}</Code>


### 读取数据-TypeScript

Prisma client基于Prisma API的GraphQL schema定义生成操作。对于_reading_数据，它基本上_复制_你Prisma service中的`GraphQL Query`。

对于此页面，我们假设你的Prisma API基于以下`datamodel`:

<Code lang="graphql">{`
type Link {
  id: ID! @unique
  createdAt: DateTime!
  description: String!
  url: String!
  postedBy: User
  votes: [Vote!]!
}
type User {
  id: ID! @unique
  name: String!
  email: String! @unique
  password: String!
  links: [Link!]!
  votes: [Vote!]!
}
type Vote {
  id: ID! @unique
  link: Link!
  user: User!
}
`}</Code>

- 你可以查看API生成的GraphQL schema[这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.graphql)
- 你可以查看生成的TypeScript client[此处](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts)。

每当使用Prisma client查询模型时，都会获取该模型的_所有字段_。无论是查询单个对象还是对象列表，都是如此。

例如，以下查询返回单个"User"的所有标量字段:

<Code lang="typescript">{`
const user: UserNode = await prisma.user({ email: "bob@prisma.io" })
`}</Code>

在这种情况下，返回的`user`对象将具有四个属性(对应于`User`模型的标量字段):`id`，`name`，`email`和`password`。

`links`和`votes`字段都是_relation fields_，因此不包含在查询中。

以下是获取`User`对象_list_的示例:

<Code lang="typescript">{`
const users: UserNode[] = await prisma.users()
`}</Code>

与前面的查询类似，`users`数组中的每个对象只有标量和无关系字段。

#### 获取单个对象

对于datamodel中的每个模型类型，在Prisma clientAPI中生成一种方法，允许获取该模型的单个对象。该方法以类型命名，但以_小写_字符开头。对于上面的示例数据模型，获取单个"User"，"Link"和"Vote"对象的三种方法称为"user"，"link"和"vote"。

这些函数的输入是一个对象，它具有模型的任何[唯一]字段作为属性。这意味着，对于所有三种方法，都接受`id`字段(因为相应的模型每个都有一个注释为`@unique`的`id`字段)。 `user`方法的输入对象另外有一个`email`字段。

查看`Link`，`User`和`Vote`的输入对象的类型

- 查看`Link`的"where"类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L455)
- 查看`User`的"where"类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L357)
- 查看`Vote`的"where"类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L522)

##### 例子

_通过其id_获取单个投票:

<Code lang="typescript">{`
const vote:VoteNode = await prisma.vote({id:"cjlgpyueg001o0a239d3i07ao"})
`}</Code>

<Code lang="graphql">{`
# generated query
query {
  vote(where: {
    id: "cjlgpyueg001o0a239d3i07ao"
  }) {
    id
  }
}
`}</Code>

_通过email_获取单个用户:

<Code lang="typescript">{`
const用户:UserNode = await prisma.user({email:"alice@prisma.io"})
`}</Code>

<Code lang="graphql">{`
# generated query
query {
  user(where: {
    email: "alice@prisma.io"
  }) {
    id
  }
}
`}</Code>

#### 获取列表

对于datamodel中的每个模型类型，在Prisma client API中生成一个方法，允许获取这些模型对象的列表。该方法以模型命名，但以_小写_字符开头并使用_复数_形式。对于上面的示例数据模型，获取"User"，"Link"和"Vote"模型列表的三种方法称为"users"，"links"和"votes"。

这些函数的输入参数是一个具有以下属性的对象:

- [过滤](#列表基础过滤):`where`
- [排序](#排序):`orderBy`
- [分页](#分页):`before`，`after`，`first`，`last`，`skip`

##### 例子

_查询 all links_:

<Code lang="typescript">{`
const links: LinkNode[] = await prisma.links()
`}</Code>

<Code lang="graphql">{`
# generated query
query {
  links {
    id
    createdAt
    url
    description
  }
}
`}</Code>

_获取users_列表:

<Code lang="typescript">{`
const users: UserNode[] = await prisma.users()
`}</Code>

<Code lang="graphql">{`
# generated query
query {
  users {
    id
    name
    email
    password
  }
}
`}</Code>

#### 关系

Prisma client基于[fluent API](https://www.sitepoint.com/javascript-like-boss-understanding-fluent-apis/)来查询数据图中的关系。这意味着你可以简单地_链式调用_你的方法来返回模型的关系属性。

**注意**

这仅在检索_单个_对象时才有可能，而不是用于列表。这意味着你无法查询列表中返回的对象的关系字段，例如:

<Code lang="typescript">{`
//不可能
const result = await prisma
  .users()
  .links()
`}</Code>

在这个例子中，`users()`已经返回一个列表，因此不可能查询列表中每个用户对象的`links`关系。

##### 例子

_Query查询单个user_的所有链接:

<Code lang="typescript">{`
const linksByUser: LinkNode[] = await prisma
  .user({ email: "alice@prisma.io" })
  .links()
`}</Code>

<Code lang="graphql">{`
query {
  user(where: {
    email: "alice@prisma.io"
  }) {
    links {
      id
      createdAt
      description
      url
    }
  }
}
`}</Code>

 _查询某个user_所做的所有投票:

<Code lang="typescript">{`
const votesByUser: VoteNode[] = await prisma
  .user({ email: "alice@prisma.io" })
  .votes()
`}</Code>

<Code lang="graphql">{`
query {
  user(where: {
    email: "alice@prisma.io"
  }) {
    votes {
      id
    }
  }
}
`}</Code>

#### 使用片段fragment进行细粒度数据访问

你可以使用`$fragment` API功能(基于GraphQL)指定要检索的字段，而不是查询模型的所有标量字段(这是默认行为)。这对于排除大量不需要的字段(如BLOB值或大字符串)或检索关系很有用。

##### 例子

_获取用户的`name`和`email`以及相关links_的`description`和`url`:

<Code lang="typescript">{`
const fragment = \`
fragment UserWithLinks on User {
  name
  email
  links {
    description
    url
  }
}
\`
const userWithPosts = await prisma.users().\$fragment(fragment)
`}</Code>

<Code lang="graphql">{`
query {
  users {
    ...UserWithLinks
  }
}
fragment UserWithLinks on User {
  name
  email
  links {
    description
    url
  }
}
`}</Code>



#### 列表的基本过滤器

_Basic_过滤器允许你指定某些条件来约束应在列表中返回哪些对象。过滤器在输入参数的`where`对象中指定，任何列表查询都接受该对象。

`where`对象的类型取决于生成它的模型。

查看`Link`，`User`和`Vote` 的`where`类型

- 查看`Link`的"where"类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L154)
- 查看`User`的"where"类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L267)
- 查看`Vote`的"where"类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L219)

也可以使用`AND`和`OR`字段_组合_多个过滤器。

##### 例子

找到名称中包含"A"的用户:

<Code lang="typescript">{`
const usersWithAInName: UserNode[] = await prisma
  .users({
    where: {
      name_contains: "A"
    }
  })
`}</Code>

<Code lang="graphql">{`
query {
  users(where: {
      name_contains: "A"
  }) {
    id
    name
    email
    password
  }
}
`}</Code>

使用自动完成功能来探索过滤系统

![](https://imgur.com/XwE5z9o.png)

_查询称为"Alice"或"Bob`的用户_:

<Code lang="typescript">{`
const usersCalledAliceOrBob: UserNode[] = await prisma
  .users({
    where: {
      name_in: ["Alice", "Bob"]
    }
  })
`}</Code>

<Code lang="graphql">{`
query {
  users(where: {
    name_in: ["Alice", "Bob"]
  }) {
    id
    name
    email
    password
  }
}
`}</Code>

_获取2018年12月24日之前创建的链接_:

<Code lang="typescript">{`
const linksBeforeChristmas: LinkNode[] = await prisma
  .links({
    where: {
      createdAt_lt: "2018-12-24" 
    }
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(where: {
    createdAt_lt: "2018-12-24" 
  }) {
    id
    createdAt
    description
    url
  }
}
`}</Code>

> Prisma clientAPI中的日期和时间遵循[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601)标准，该标准通常具有以下形式:`YYYY-MM-DDThh:mm:ss`。

_查询在description中有`prisma` **或**`graphql`的链接**并且是**在2018年创建的_:

<Code lang="typescript">{`
const filteredLinks: LinkNode[] = await prisma
  .links({
    where: {
      AND: [
        {
          OR: [{
            description_contains: "graphql",
          }, {
            description_contains: "prisma",
          }]
        }, 
        {
          AND: [{
            createdAt_gt: "2017"
          }, {
            createdAt_lt: "2019"
          }]
        }
      ],
    }
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(where: {
    OR: [{
      description_contains: "graphql",
    }, {
      description_contains: "prisma",
    }]
    AND: [{ 
      createdAt_lt: "2019"
    }, { 
      createdAt_gt: "2017" 
    }]
  }) {
    id
    description
  }
}
`}</Code>

实际上可以省略`AND`过滤器，因为默认情况下使用_logical and_组合了多个过滤条件。这意味着上面的过滤器也可以表示如下:

<Code lang="typescript">{`
const filteredLinks: LinkNode[] = await prisma
  .links({
    where: {
      OR: [{
        description_contains: "graphql"
      }, {
        description_contains: "prisma"
      }],
      createdAt_gt: "2017",
      createdAt_lt: "2019"
    }
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(where: {
    OR: [{
      description_contains: "graphql",
    }, {
      description_contains: "prisma",
    }],
    createdAt_lt: "2019",
    createdAt_gt: "2017" 
  }) {
    id
    createdAt
    description
    url
  }
}
`}</Code>

#### 列表的关系过滤器

关系过滤器可用于约束关系列表字段上的返回对象。用于过滤的类型与基本过滤器相同，唯一的区别是过滤器不应用于方法调用的第一级，而是在第二级查询关系时。

##### 例子

<Code lang="typescript">{`
const linksByUserBeforeChristmas: LinkNode[] = await prisma
  .user({ email: "alice@prisma.io" })
  .links({
    where: {
      createdAt_lt: "2017-12-24" 
    }
  })
`}</Code>

<Code lang="graphql">{`
query {
 user(where: {
  email: "alice@prisma.io"
 }) {
    links(where: {
      createdAt_lt: "2017-12-24" 
    }) {
      id
      createdAt
      description
      url
  }
 }
}
`}</Code>



#### 排序

查询模型对象列表时，可以按该模型类型的任何标量字段对列表进行排序。因此，每个生成的查询模型列表的方法都接受其输入对象上的`orderBy`字段。

`orderBy`字段的类型取决于生成它的模型的标量字段。

查看`link`，`user`和'vote'的`orderBy`类型

- 查看`link` 的`orderBy`类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L114)
- 查看`user` 的`orderBy`类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L132)
- 查看`Vote` 的`orderBy`类型[here](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L125)

##### 例子

_按创建日期(升序)_links:

<Code lang="typescript">{`
const sortedLinks: LinkNode[] = prisma
  .links({
    orderBy: "createdAt_ASC"
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(orderBy: createdAt_ASC) {
    id
    createdAt
    description
    url
  }
}
`}</Code>



_按字母顺序排序用户名(降序)_:

<Code lang="typescript">{`
const sortedUsers: UserNode[] = prisma
  .users({
    orderBy: "name_DESC"
  })
`}</Code>

<Code lang="graphql">{`
query {
  users(orderBy: name_DESC) {
    id
    name
    email
    password
  }
}
`}</Code>




#### 分页

查询模型对象列表时，可以通过提供分页参数来获取该列表的_部分信息_。常在feed流中使用。

##### 用'first`和`last`向前和从后往前

你可以在对象中向前或从后往前并提供可选的起始对象:

- 要 **从前往后**，使用`first`;用`after`指定一个起始对象。
- 要 **从后往前**，请使用`last`;用`before`指定一个起始对象。

你 **不能**将`first`与`before`或`last`与`after`结合起来。如果你在查询中这样做，`before`/`after`将被忽略，实际上只应用`first`或`last`(在列表的开头或结尾，取决于你使用的是哪个) 。

请注意，你可以在没有错误消息的情况下查询比实际存在的对象更多的对象。

##### 使用`skip`跳过元素

你还可以通过提供`skip`参数跳过任意方向的任意数量的对象:

- 当使用`first`时，`skip`会跳过列表开头的对象。
- 当使用`last`时，`skip`跳过列表末尾的对象。

##### 例子

对于以下示例，我们假设一个正好包含30个对象的列表:

![](https://i.imgur.com/Xh6Qjts.png)

_查询前3个链接(从前往后)_:

![](https://i.imgur.com/O1Jj3Z2.png)

<Code lang="typescript">{`
const links: LinkNode[] = await prisma
  .links({
    first: 3
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(first: 3) {
    id
    createdAt
    description
    url
  }
}
`}</Code>



_查询从位置6到位置10的对象(从前往后)_:

![](https://i.imgur.com/PpI5X0X.png)

<Code lang="typescript">{`
const links: LinkNode[] = await prisma
  .links({
    first: 5, 
    skip: 5
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(
    first: 5 
    skip: 5
  ) {
    id
    createdAt
    description
    url
  }
}
`}</Code>



_查询最后3个对象(从后往前)_:

![](https://i.imgur.com/pkuYCrV.png)

<Code lang="typescript">{`
const links: LinkNode[] = await prisma
  .links({
    last: 3
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(last: 3) {
    id
    createdAt
    description
    url
  }
}
`}</Code>



_查询从第21位到第27位的对象(从后往前)_:

![](https://i.imgur.com/iSl9Y07.png)

<Code lang="typescript">{`
const links: LinkNode[] = await prisma
  .links({
    last: 7,
    skip: 3
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(
    last: 7
    skip: 3
  ) {
    id
    createdAt
    description
    url
  }
}
`}</Code>

使用`cixnen24p33lo0143bexvr52n`作为`id`_查询对象之后的前3个对象_:

![](https://i.imgur.com/InYSSkQ.png)

<Code lang="typescript">{`
const links: LinkNode[] = await prisma
  .links({
    first: 3,
    after: "cixnen24p33lo0143bexvr52n"
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(
    first: 3
    after: "cixnen24p33lo0143bexvr52n"
  ) {
    id
    createdAt
    description
    url
  }
}
`}</Code>

使用`cixnen24p33lo0143bexvr52n`作为`id`跳过3条数据查询后面的5个对象:

![](https://i.imgur.com/u4WEAJv.png)

<Code lang="typescript">{`
const links: LinkNode[] = await prisma
  .links({
    first: 5,
    after: "cixnen24p33lo0143bexvr52n",
    skip: 3
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(
    first: 5
    after: "cixnen24p33lo0143bexvr52n"
    skip: 3
  ) {
    id
    createdAt
    description
    url
  }
}
`}</Code>

使用`cixnen24p33lo0143bexvr52n`作为`id`_查询对象之前的最后5个对象_:

![](https://i.imgur.com/306eghw.png)

<Code lang="typescript">{`
const links: LinkNode[] = await prisma
  .links({
    last: 5,
    before: "cixnen24p33lo0143bexvr52n"
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(
    last: 5
    before: "cixnen24p33lo0143bexvr52n"
  ) {
    id
    createdAt
    description
    url
  }
}
`}</Code>



_查询节点之前的最后3个节点，其中cixnen24p33lo0143bexvr52n为id并跳过5个_:

![](https://i.imgur.com/iZGUiHJ.png)

<Code lang="typescript">{`
const links: LinkNode[] = await prisma
  .links({
    last: 3,
    before: "cixnen24p33lo0143bexvr52n",
    skip: 5
  })
`}</Code>

<Code lang="graphql">{`
query {
  links(
    last: 3 
    before: "cixnen24p33lo0143bexvr52n"
    skip: 5
  ) {
    id
    createdAt
    description
    url
  }
}
`}</Code>

#### 聚合

你可以通过[Connection查询]提交聚合查询。支持以下聚合功能:

- `count`:计算列表中的对象数
- `avg`(_即将推出_):计算数字列表的平均值。
- `median`(_即将推出_):计算数字列表的中位数。
- `max`(_即将推出_):返回数字列表中最大的元素。
- `min`(_即将推出_):返回数字列表中的最小元素。
- `sum`(_即将推出_):计算数字列表的总和。

> 请参阅[this](https://github.com/prisma/prisma/issues/1312)GitHub问题以了解有关即将推出的聚合功能的更多信息。

##### 例子

_Count链接对象的数量_:

<Code lang="typescript">{`
const linkCount: number = await prisma
  .linksConnection()
  .aggregate()
  .count()
`}</Code>

<Code lang="graphql">{`
query {
  linksConnection {
    aggregate {
      count
    }
  }
}
`}</Code>


### 写入数据-TypeScript


对于前面创建的的数据模型，每个模型类型生成了写入数据六种方法。这些在GraphQL schema，例如用于`User`模型中的Mutation而得到:

- `createUser`:创建一个新的`User`记录在数据库中 
- `updateUser`:更新现有`User`记录在数据库中
- `deleteUser`:从数据库中删除现有的`User`记录
- `upsertUser`:更新现有的或在数据库中创建一个新的`User`纪录
- `updateManyUsers`:更新许多现有的`User`数据库中的记录
- `deleteManyUsers`:从数据库中删除现有的许多`User`记录

- 你可以查看一下生成GraphQL schema的API [这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.graphql)
- 你可以查看要生成的JavaScript client[这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts)。



这些方法中的一个的每个调用被作为[事务]执行，这意味着它要么保证完全成功，或者如果它只是部分地失败但要被全部取消而回到原先状态，所以不必担心数据一致性。

#### 创建对象

当在数据库中创建新的记录，`create`方法需要用一个输入对象包裹起来所有数据。它还提供了一种用于模型创建关系数据，这可以通过使用[嵌套对象写入](#嵌套对象写入)来提供。

每个方法调用的返回包含刚刚创建的模型的所有字段。

- 查看createLink`的`的输入对象的类型(这里)(https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L567)
- 查看createUser`的`的输入对象的类型(这里)(https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L418)
- 查看createVote`的`的输入对象的类型(这里)(https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L214)

##### 例子

_create新用户_:

<Code lang="typescript">{`
const newUser: UserNode = await prisma
  .createUser({
    name: "Alice",
    email: "alice@prisma.io",
    password: "IlikeTurtles"
  })
`}</Code>

<Code lang="graphql">{`
# generated mutation
mutation {
  createUser(data: {
    name: "Alice"
    email: "alice@prisma.io"
    password: "IlikeTurtles"
  }) {
    id
    name
    email
    password
  }
}
`}</Code>



_create新vote_:

<Code lang="typescript">{`
const newVote: VoteNode = await prisma
  .createVote({
    user: {
      connect: {
        email: "alice@prisma.io"
      }
    },
    link: {
      connect: {
        id: "cjli47wr3005b0a23m9crhh0e"
      }
    }
  })
`}</Code>

<Code lang="graphql">{`
# generated mutation
mutation {
  createVote(data: {
    user: {
      connect: {
        email: "alice@prisma.io"
      }
    }
    link: {
      connect: {
        id: "cjli47wr3005b0a23m9crhh0e"
      }
    }
  }) {
    id
  }
}
`}</Code>



_create新用户并加两个新links_:

<Code lang="typescript">{`
const newUserWithLinks: UserNode = await prisma
  .createUser({
    name: "Alice",
    email: "alice@prisma.io",
    password: "IlikeTurtles",
    links: {
      create: [{
        description: "My first link",
        url: "https://www.prisma.io"
      }, {
        description: "My second link",
        url: "https://www.howtographql.com"
      }]
    }, 
  })
`}</Code>

<Code lang="graphql">{`
# generated mutation
mutation {
  createUser(data: {
    name: "Alice"
    email: "alice@prisma.io"
    password: "IlikeTurtles"
    links: {
      create: [{
        description: "My first link",
        url: "https://www.prisma.io"
      }, {
        description: "My second link",
        url: "https://www.howtographql.com"
      }]
    }
  }) {
    id
    name
    email
    password
  }
}
`}</Code>

#### 更新对象

当在数据库中更新现有记录中，`update`-方法接收具有两个字段的一个输入对象:

 - `data`:这类似于你提供给一个`create`-方法输入对象。它包含模型更新的字段，让你提供的关系数据通过[嵌套对象写入](#嵌套对象写入)。
 - `where`:这是用来选择要更新的记录。你可以使用任何[唯一]字段来标识记录。

查看`data`的类型和`where`用于`Link`，`User`和`Vote`

- `data`
  - 查看`updateLink`的`data`字段的类型[这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L255)
  - 查看`updateUser`的`data`字段的类型[这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L468)
  - 查看`updateVote`的`data`字段的类型[这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L366)
- `where`
  - 查看`updateLink`的`where`字段的类型[这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L455)
  - 查看`updateUser`的`where`字段的类型[这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L357)
  - 查看`updateVote`的`where`字段的类型[这里](https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L522)

每个方法调用返回一个包含刚更新了模型的所有字段的对象。

##### 例子

_设置现有用户_一个新的名字:

<Code lang="typescript">{`
const updatedUser: UserNode = await prisma
  .updateUser({
    data: {
      name: "Alice"
    },
    where: {
      id: "cjli512bd005g0a233s1ogbgy"
    }
  })
`}</Code>

<Code lang="graphql">{`
# generated mutation
mutation {
  updateUser(
    data: {
      name: "Alice"
    }
    where: {
      id: "cjli512bd005g0a233s1ogbgy"
    }
  ) {
    id
    name
    email
    password
  }
}
`}</Code>

_Update一个链接，改变它的发布者为不同的用户_:

<Code lang="typescript">{`
const updatedLink: LinkNode = await prisma
  .updateLink({
    data: {
      postedBy: {
        connect: {
          id: "cjli512bd005g0a233s1ogbgy"
        }
      },
    },
    where: {
      id: "cjli47wr3005b0a23m9crhh0e"
    }
  })
`}</Code>

<Code lang="graphql">{`
mutation {
  updateLink(
    data: {
      postedBy: {
        connect: {
          id: "cjli512bd005g0a233s1ogbgy"
        }
      }
    }
    where: {
      id: "cjli47wr3005b0a23m9crhh0e"
    }
  ) {
    id
    createdAt
    description
    url
  }
}
`}</Code>



_delete发布vote的用户_:

<Code lang="typescript">{`
const updatedVote: VoteNode = await prisma
  .updateVote({
    data: {
      user: {
        delete: true
      },
    },
    where: {
      id: "cjli5aual005n0a233ekv89o4"
    }
  })
`}</Code>

<Code lang="graphql">{`
mutation {
  updateVote(
    data: {
      user: {
        delete: true
      }
    }
    where: {
      id: "cjli5aual005n0a233ekv89o4"
    }
  ) {
    id
  }
}
`}</Code>

> 为了成功执行此操作，vote的user不能是必填字段。否则，每一个`Vote`需要连接到一个`User`，删除就报错了。  

#### 删除对象

当从数据库中删除记录，该`delete`-方法接收一个输入对象，指定哪个记录是要被删除。类型此输入对象的是相同的`update`-方法`where`对象。

该对象的属性对应于被标记为[唯一](#唯一)的模型的那些字段。对于上面的示例数据模型，这意味着，对于`User`，`Vote`和`Link`它有一个`id`属性。对于`User`它另外接受`email`字段。

查看类型的输入对象的`Link`，`User`和`Vote` 

- 查看deleteLink`的`的输入对象的类型(这里)(https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L455)
- 查看deleteUser`的`的输入对象的类型(这里)(https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L357)
- 查看deleteVote`的`的输入对象的类型(这里)(https://github.com/nikolasburk/prisma-client-examples/blob/master/generated/prisma.ts#L522)

每个方法调用返回一个包含刚删除的模型的所有字段的对象。

##### 例子

_delete其ID_链接:

<Code lang="typescript">{`
const deletedLink: LinkNode = await prisma
  .deleteLink({
    id: "cjli47wr3005b0a23m9crhh0e"
  })
`}</Code>

<Code lang="graphql">{`
mutation {
  deleteLink(where: {
    id: "cjli47wr3005b0a23m9crhh0e"
  }) {
    id
    createdAt
    description
    url
  }
}
`}</Code>

_通过他们的email来delete_用户:

<Code lang="typescript">{`
const deletedUser: UserNode = await prisma
  .deleteUser({
    email: "alice@prisma.io"
  })
`}</Code>

<Code lang="graphql">{`
mutation {
  deleteUser(where: {
    email: "alice@prisma.io"
  }) {
    id
    createdAt
    description
    url
  }
}
`}</Code>

#### 创建或更新对象(upserts)

UPSERT操作允许你_尝试_更新现有的记录。如果该记录实际上还不存在，它将被创建。该`upsert`的方法是`create`-和`update`-的搭配方法，这意味着他们收到有三个字段输入参数:

- `where`:相同于在`update`方法中提供的`where`字段
- `update`:相同于在`update`的方法中提供的`data`字段
- `create`:相同于在`create`的方法中提供的输入input

##### 例子

_Update链接的URL。如果该链接不存在，创建一个新的_:

<Code lang="typescript">{`
const updatedOrCreatedLink: LinkNode = await prisma
  .upsertLink({
    where: {
      id: "cjli47wr3005b0a23m9crhh0e"
    },
    update: {
      url: "https://www.howtographql.com"
    },
    create: {
      url: "https://www.howtographql.com",
      description: "Fullstack GraphQL Tutorial"
    }
  })
`}</Code>

<Code lang="graphql">{`
mutation {
  upsertLink(
    where: {
      id: "cjli47wr3005b0a23m9crhh0e"
    }
    update: {
      url: "https://www.howtographql.com"
    }
    create: {
      url: "https://www.howtographql.com"
      description: "Fullstack GraphQL Tutorial"
    }
  ) {
    id
  }
}
`}</Code>




#### 更新和删除多条记录

该Prisma的clientAPI提供了特殊的方法来更新或一次删除多条记录。GraphQL API中的相应的Mutation被称为[批量Mutation(#批量Mutation)。每个`updateMany`-和`deleteMany`-方法返回最终受到影响的操作记录数。

##### 例子

_Update三个links，通过其ID指定，将其网址重置为空string_:

<Code lang="typescript">{`
const updatedLinksCount: number = await prisma
  .updateManyLinks({
    where: {
      id_in: ["cjli6tknz005s0a23uf0lmlve", "cjli6tnkj005x0a2325ynfpb9", "cjli6tq3200620a23s4lp8npd"]
    },
    data: {
      url: ""
    },
  }).count
`}</Code>

<Code lang="graphql">{`
mutation {
  updateManyLinks({
    where: {
      id_in: ["cjli6tknz005s0a23uf0lmlve", "cjli6tnkj005x0a2325ynfpb9", "cjli6tq3200620a23s4lp8npd"]
    }
    data: {
      url: ""
    }
  }) {
    count
  }
}
`}</Code>



**注意**

如果一个或多个所提供的ID没有在数据库中实际存在，操作将 **不返回**错误。

_Update 所有links的描述中包含字符串'graphql`的数据，其网址重置为空string_:

<Code lang="typescript">{`
const updatedLinksCount: number = await prisma
  .updateManyLinks({
    where: {
      description_contains: "graphql"
    },
    data: {
      url: ""
    },
  }).count
`}</Code>

<Code lang="graphql">{`
mutation {
  updateManyLinks({
    where: {
      description_contains: "graphql"
    }
    data: {
      url: ""
    }
  }) {
    count
  }
}
`}</Code>



_delete在2018年之前创建的所有链接_:

<Code lang="typescript">{`
const deleteLinksCount: number = await prisma
  .deleteManyLinks({
    createdAt_lte: "2018"
  }).count
`}</Code>

<Code lang="graphql">{`
mutation {
  deleteManyLinks(where: {
    createdAt_lte: "2018"
  }) {
    count
  }
}
`}</Code>



#### 嵌套对象写入

嵌套的对象写入操作让你在一个单一的Mutation中修改多个模型数据库记录。Prisma的GraphQL API相应的概念被称为[嵌套Mutation](#嵌套的Mutation)。嵌套对象写入可供`create`-和`update`的方法。

如果模型具有相对于不同的schema，对应关系字段被设定为具有以下性质中的一个子集的对象:

- `create`:创建相关模型的新纪录，并通过关系将其连接。
- `update`:更新通过关系已经连接了相关模型的现有记录。
- `upsert`:更新相关模型的现有记录或创建并连接一个新的。 
- `delete`:删除通过关系连接的相关模型的现有记录。
- `connect`:通过连接关系的相关模型的现有记录。
- `disconnect`:删除通过关系连接相关模型的现有记录。

##### 例子

_create新用户和两个新的link，并连接一个现有的link_:

<Code lang="typescript">{`
const newUserWithLinks: UserNode = await prisma
  .createUser({
    name: "Alice",
    email: "alice@prisma.io",
    password: "IlikeTurtles",
    links: {
      create: [{
        description: "My first link",
        url: "https://www.prisma.io"
      }, {
        description: "My second link",
        url: "https://www.howtographql.com"
      }],
      connect: {
        id: "cjli6tknz005s0a23uf0lmlve"
      }
    }, 
  })
`}</Code>

<Code lang="graphql">{`
# generated mutation
mutation {
  createUser(data: {
    name: "Alice"
    email: "alice@prisma.io"
    password: "IlikeTurtles"
    links: {
      create: [{
        description: "My first link",
        url: "https://www.prisma.io"
      }, {
        description: "My second link",
        url: "https://www.howtographql.com"
      }]
      connect: {
        id: "cjli6tknz005s0a23uf0lmlve"
      }
    }
  }) {
    id
    name
    email
    password
  }
}
`}</Code>



_delete用户的链接_:

<Code lang="typescript">{`
const updatedUser: UserNode = await prisma
  .updateUser({
    where: {
      id: "cjli8znnd006n0a23ywc6wf8w"
    },
    data: {
      links: {
        delete: {
          id: "cjli6tknz005s0a23uf0lmlve"
        }
      }
    }
  })
`}</Code>

<Code lang="graphql">{`
mutation {
  updateUser(
    where: {
      id: "cjli8znnd006n0a23ywc6wf8w"
    }
    data: {
      links: {
        delete: {
          id: "cjli6tknz005s0a23uf0lmlve"
        }
      }
    }
  ) {
    id
  }
}
`}</Code>


#### 实时数据-TypeScript

该Prisma的client，使用`\$subscribe`属性实时更新和订阅数据库事件和数据。对于你的数据模型中的每个模型类型，Prisma client公开以此属性的模型命名的(小写)一个函数：Subscriptions。使用此函数意味着比对该模型的[写入]事件（即_create_，_update_，_delete_）有实时需求。你可以提供一个过滤器对象，使得可以进一步约束要接收更新的事件类型。该函数返回[async iterator](https://github.com/tc39/proposal-async-iteration)，只要发生指定的数据库事件，就会发出事件通知。

该`\$subscribe` API是基于[WebSockets的(https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)。

##### 例子

_Subscribe"新建"和"更新"`User`_的事件:

<Code lang="typescript">{`
const createdAndUpdatedUserIterator: UserAsyncIterator = await db.$subscribe.user({
  mutation_in: ['CREATED', 'UPDATED']
}).node()
`}</Code>

 _Subscribe`User`的电子邮件地址有包含字符串'gmail`的更新:

 <Code lang="typescript">{`
const userIterator: UserAsyncIterator = await db.$subscribe.user({
  email_contains: \`gmail\` 
}).node()
`}</Code>

### 检查是否存在-TypeScript

该Prisma的client，你可以为你在使用`$exists`属性中的数据库中是否存在一定的记录。对于你的[数据模型]每个模型类型，Prisma client公开此属性的模型命名的(小写)一个函数。这些函数的接收过滤对象作为指定该记录的条件，并返回一个布尔值;如果有至少一个数据库记录符合指定过滤，该值是TRUE，否则返回FALSE。

输入对象具有用于[过滤列表]相同的类型。

#### 例子

_检查是否有具有特定ID 存在_的用户:

<Code lang="typescript">{`
const userExists: boolean = prisma.$exists.user({
  id: "cjli6tko8005t0a23fid7kke7"
})
`}</Code>

_检查是否有用户名为`Alice`或`Bob` 的user存在_:

<Code lang="typescript">{`
const userExists: boolean = prisma.$exists.user({
  name_in: ['Alice', 'Bob']
})
`}</Code>

检查是否有在描述中有`prisma`或`graphql`字段存在的link，并且创建于2018年:

<Code lang="typescript">{`
const linkExists: boolean = await prisma.$exists.link({
  AND: [
    {
      OR: [{
        description_contains: "graphql",
      }, {
        description_contains: "prisma",
      }]
    },
    {
      AND: [{
        createdAt_gt: "2017"
      }, {
        createdAt_lt: "2019"
      }]
    }
  ],
})
`}</Code>

### graphql-requests-TypeScript

该Prisma的client，可以直接发送GraphQL Query和Mutation，`$request`方法请求你的Prisma service:

<Code lang="typescript">{`
$request: <T = any>(query: string, variables?: {[key: string]: any}) => Promise<T>;
`}</Code>

#### 例子

_查询单个用户_:

<Code lang="typescript">{`
  query {
    user(id: "cjcdi63j80adw0146z7r59bn5") {
      id
      name
    }
  }
const result: any = prisma.$request(query)
// 示例result:
// {"data": { "user": { "id": "cjcdi63j80adw0146z7r59bn5", "name": "Sarah" } } }
`}</Code>


_使用variables查询_单个用户:

<Code lang="typescript">{`
  query ($userId: ID!){
    user(id: $userId) {
      id
      name
    }
  }
const variables: UserWhereUniqueInput = { id: 'cjcdi63j80adw0146z7r59bn5' }
const result: any = prisma.$request(query, variables)
  .then(result => console.log(result))
// 示例result:
// {"data": { "user": { "id": "cjcdi63j80adw0146z7r59bn5", "name": "Sarah" } } }
`}</Code>

### 读取数据-Go

每当使用Prisma client查询模型时，都会获取该模型的_all标量fields_。 无论是查询单个对象还是对象列表，都是如此。

例如，以下查询返回单个"User"的所有标量字段:

<Code lang="go">{`
user := client.User(&prisma.UserWhereInput{ "email": "bob@prisma.io" })
`}</Code>

在这种情况下，返回的`user`对象将具有四个属性(对应于`User`模型的标量字段):`id`，`name`，`email`和`password`。

`links`和`votes`字段都是_relation fields_，因此不包含在查询中。

以下是获取`User`对象_list_的示例:

<Code lang="go">{`
users := client.Users(nil).Exec()
`}</Code>

与前面的查询类似，`users`数组中的每个对象只有标量和无关系字段。

### 写入数据-Go

与JS和TS类似，仅语法不同。

#### 创建对象

当在数据库中创建新的记录，`create`法需要它包装上创建的所有记录的字段一个输入对象。它还提供了一种用于模型创建关系数据，这可以通过使用[嵌套对象写入](#嵌套对象写入)来供给。

每个方法调用返回包含刚刚创建的模型的所有字段的对象。

##### 例子

_create新用户_:

<Code lang="go">{`
name := "Alice",
email := "alice@prisma.io",
password := "IlikeTurtles"
newUser, err := db.CreateUser(&prisma.UserCreateInput{
  Name: &name,
  Email: &email,
  Password: &password,
}).Exec()
`}</Code>

<Code lang="graphql">{`
# generated mutation
mutation {
  createUser(data: {
    name: "Alice"
    email: "alice@prisma.io"
    password: "IlikeTurtles"
  }) {
    id
    name
    email
    password
  }
}
`}</Code>

### Subscription-Go

目前暂时没有。

### 检查是否存在-Go

##### 例子

_检查是否具有特定ID存在_的用户:

<Code lang="go">{`
userExists := client.Exists.User(&prisma.UserWhereUniqueInput{
  ID: "cjli6tko8005t0a23fid7kke7",
})
`}</Code>

#### graphql-request-go

该Prisma的client，你可以直接使用`$request`方法发送GraphQL Query和Mutation到你的Prisma service:

<Code lang="typescript">{`
GraphQL(query string, variables map[string]interface{}) (map[string]interface{}, error)
`}</Code>

由于GraphQL操作传递无类型(作为一个普通字符串)，返回的承诺的类型是`any`。

##### 例子

_查询单个用户_:

<Code lang="typescript">{`
query := \`
  query {
    user(id: "cjcdi63j80adw0146z7r59bn5") {
      id
      name
    }
  }
\`
result := client.GraphQL(query, nil)
// sample result:
// map[data:[map[user:[map[id:cjcdi63j80adw0146z7r59bn5 name:Sarah]]]]]
`}</Code>


_使用variables_查询单个用户:

<Code lang="javascript">{`
query := \`
  query ($id: ID!){
    user(id: $id) {
      id
      name
    }
  }
\`
variables := map[string]interface{}{
  "id": "cjcdi63j80adw0146z7r59bn5",
result := client.GraphQL(query, variables)
// sample result:
// map[data:[map[user:[map[id:cjcdi63j80adw0146z7r59bn5 name:Sarah]]]]]
`}</Code>

_Creating新用户_:

<Code lang="javascript">{`
mutation := \`
  mutation ($name: String!){
    createUser(name: $name) {
      id
      name
    }
  }
\`
variables := map[string]interface{}{ "name": "Alice" }
result := client.GraphQL(mutation, variables)
// sample result:
// map[data:[map[createUser:[map[id:cjlhqfbfa003t0a23rhzjragl name:Alice]]]]]
//{ "数据":{ "的createUser":{ "ID": "cjlhqfbfa003t0a23rhzjragl"， "名": "爱丽丝"}}}
`}</Code>


下一节是Prisma概念，来深入理解它。

<InternalLink href="/docs/part4" as="/docs/part4">深入理解Prisma</InternalLink>
